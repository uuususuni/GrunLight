<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GrunLight • 신호 잔여시간 미니 웹</title>
  <style>
    :root{--bg:#0b0c10;--card:#15161a;--muted:#8a8f98;--acc:#4ade80;--warn:#fbbf24;--err:#f87171;--txt:#f3f4f6}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--txt);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif}
    header{padding:20px 16px;border-bottom:1px solid #222}
    h1{margin:0;font-size:18px}
    main{display:grid;grid-template-columns:1fr;gap:16px;max-width:980px;margin:0 auto;padding:16px}
    .card{background:var(--card);border:1px solid #222;border-radius:14px;padding:14px}
    .row{display:grid;grid-template-columns:repeat(7,minmax(0,1fr));gap:8px}
    label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
    input,button,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2a2b31;background:#0e0f13;color:var(--txt)}
    button{background:#11151a;border-color:#2a2b31;cursor:pointer}
    button.primary{background:var(--acc);color:#072c11;border:none}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid #23242a;text-align:left}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px}
    .green{background:rgba(74,222,128,.15);color:#86efac}
    .red{background:rgba(248,113,113,.15);color:#fecaca}
    .muted{color:var(--muted)}
    .flex{display:flex;gap:8px;align-items:center}
    .right{margin-left:auto}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

    /* LIVE PANEL */
    .live{display:flex;gap:16px;align-items:center}
    .live .big{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:16px 8px}
    .stateBadge{font-weight:700;font-size:14px;padding:6px 10px;border-radius:999px}
    .stateGREEN{background:rgba(74,222,128,.18);color:#bbf7d0}
    .stateRED{background:rgba(248,113,113,.18);color:#fecaca}
    .timer{font-size:64px;line-height:1.05;font-weight:800;letter-spacing:1px;margin:8px 0 0}
    .sub{font-size:12px;color:var(--muted)}
    .blink{animation:blink 1s step-start infinite}
    @keyframes blink{50%{opacity:.45}}
    .gridTwo{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .kicker{font-size:12px;color:var(--muted);margin-bottom:6px}
    .rowClick tbody tr{cursor:pointer}
    .rowClick tbody tr:hover{background:#111216}
  </style>
</head>
<body>
<header>
  <h1>🚦 GrunLight • 신호 잔여시간 미니 웹</h1>
  <div class="muted">cycle/green/offset/reference_epoch만 알면 지금 GREEN/RED와 잔여초를 계산합니다. (UTC 기준)</div>
</header>
<main>
  <!-- LIVE PANEL -->
  <section class="card">
    <div class="flex"><div class="muted">라이브 패널</div><div class="right muted">UTC 현재시각: <span id="utcNow" class="mono"></span></div></div>
    <div class="live">
      <div class="big">
        <div id="liveName" style="font-size:16px;font-weight:600">항목을 추가하세요</div>
        <div id="liveState" class="stateBadge stateRED" style="margin-top:8px">-</div>
        <div id="liveTimer" class="timer">00:00</div>
        <div id="liveSub" class="sub">cycle 0s • green 0s • offset 0s</div>
      </div>
    </div>
  </section>

  <!-- INPUTS -->
  <section class="card">
    <div class="row" style="align-items:end">
      <div>
        <label>이름</label>
        <input id="name" placeholder="예) 신사역 푸른저축은행" />
      </div>
      <div>
        <label>cycle (초)</label>
        <input id="cycle" type="number" placeholder="예) 190" />
      </div>
      <div>
        <label>green (초)</label>
        <input id="green" type="number" placeholder="예) 55" />
      </div>
      <div>
        <label>offset (초)</label>
        <input id="offset" type="number" value="0" />
      </div>
      <div>
        <label>reference_epoch (UTC, ISO8601)</label>
        <input id="epoch" class="mono" placeholder="예) 2025-09-06T11:50:50Z" />
      </div>
      <div>
        <label>위도(lat)</label>
        <input id="lat" type="number" step="0.000001" placeholder="선택" />
      </div>
      <div>
        <label>경도(lng)</label>
        <input id="lng" type="number" step="0.000001" placeholder="선택" />
      </div>
    </div>
    <div class="flex" style="margin-top:10px">
      <button class="primary" id="addBtn">리스트에 추가</button>
      <button id="demoBtn">샘플(신사역 푸른저축은행)</button>
      <button id="geoBtn">가까운 항목 선택(베타)</button>
    </div>
  </section>

  <!-- TABLE -->
  <section class="card">
    <div class="flex">
      <div class="muted">추가한 횡단보도 (행 클릭→ 라이브 패널로 고정)</div>
      <div class="right">
        <button id="exportBtn">JSON 내보내기</button>
        <button id="clearBtn">모두 삭제</button>
      </div>
    </div>
    <table id="tbl" class="rowClick">
      <thead>
        <tr>
          <th>이름</th>
          <th>상태</th>
          <th>잔여 초</th>
          <th>phase</th>
          <th>cycle/green/offset</th>
          <th>reference_epoch (UTC)</th>
          <th>좌표</th>
          <th></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>
</main>

<script>
const storeKey = 'gl_intersections_v2';
let items = [];
let currentIdx = 0; // 라이브 패널에 표시할 대상

function fmtUtcNow(){ return new Date().toISOString(); }
function pad(n){return n<10?('0'+n):(''+n)}
function fmtClock(sec){ sec=Math.max(0,Math.floor(sec)); const m=Math.floor(sec/60), s=sec%60; return `${pad(m)}:${pad(s)}` }

function load(){ try{ items = JSON.parse(localStorage.getItem(storeKey)||'[]'); }catch{ items=[] } }
function save(){ localStorage.setItem(storeKey, JSON.stringify(items)); }
function addItem(obj){ items.push(obj); save(); render(); fixLiveIndex(); }
function removeAt(i){ items.splice(i,1); if(currentIdx>=items.length) currentIdx=items.length-1; save(); render(); fixLiveIndex(); }
function fixLiveIndex(){ if(items.length===0) currentIdx=0; else if(currentIdx<0) currentIdx=0; }

function compute(nowMs, it){
  const ref = Date.parse(it.reference_epoch);
  if(isNaN(ref)) return {state:'ERR', remaining:0, phase:0};
  const cycle = +it.cycle_sec, green = +it.green_sec, offset = +it.offset_sec;
  if(!(cycle>0 && green>=0 && green<=cycle)) return {state:'ERR', remaining:0, phase:0};
  const elapsed = Math.max(0, (nowMs - ref)/1000); // 부동소수
  const phase0 = elapsed % cycle;
  const phase = (phase0 + (offset%cycle)+cycle)%cycle;
  let state, remaining;
  if(phase < green){ state = 'GREEN'; remaining = green - phase; }
  else { state = 'RED'; remaining = cycle - phase; }
  return {state, remaining, phase};
}

function render(){
  const nowMs = Date.now();
  document.getElementById('utcNow').textContent = fmtUtcNow();

  // 테이블 렌더
  const tbody = document.querySelector('#tbl tbody');
  tbody.innerHTML = '';
  items.forEach((it, i)=>{
    const {state, remaining, phase} = compute(nowMs, it);
    const tr = document.createElement('tr');
    tr.onclick = ()=>{ currentIdx = i; renderLive(nowMs); };

    const tdName = document.createElement('td'); tdName.textContent = it.name; tr.appendChild(tdName);

    const tdState = document.createElement('td');
    tdState.innerHTML = state==='GREEN' ? '<span class="pill green">GREEN</span>' : (state==='RED' ? '<span class="pill red">RED</span>' : '<span class="pill">ERR</span>');
    tr.appendChild(tdState);

    const tdRem = document.createElement('td'); tdRem.className='mono'; tdRem.textContent = Math.floor(remaining); tr.appendChild(tdRem);

    const tdPhase = document.createElement('td'); tdPhase.className='mono'; tdPhase.textContent = Math.floor(phase); tr.appendChild(tdPhase);

    const tdCfg = document.createElement('td'); tdCfg.className='mono'; tdCfg.textContent = `${it.cycle_sec}/${it.green_sec}/${it.offset_sec}`; tr.appendChild(tdCfg);

    const tdEpoch = document.createElement('td'); tdEpoch.className='mono'; tdEpoch.textContent = it.reference_epoch; tr.appendChild(tdEpoch);

    const tdCoord = document.createElement('td'); tdCoord.className='mono'; tdCoord.textContent = (it.lat?it.lat:'') + (it.lng?','+it.lng:''); tr.appendChild(tdCoord);

    const tdBtn = document.createElement('td');
    const delBtn = document.createElement('button'); delBtn.textContent = '삭제';
    delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); removeAt(i); });
    tdBtn.appendChild(delBtn); tr.appendChild(tdBtn);

    tbody.appendChild(tr);
  });

  // 라이브 패널 렌더
  renderLive(nowMs);
}

function renderLive(nowMs){
  const nameEl = document.getElementById('liveName');
  const stateEl = document.getElementById('liveState');
  const timerEl = document.getElementById('liveTimer');
  const subEl = document.getElementById('liveSub');

  if(items.length===0){
    nameEl.textContent = '항목을 추가하세요';
    stateEl.textContent = '-';
    stateEl.className = 'stateBadge';
    timerEl.textContent = '00:00';
    subEl.textContent = 'cycle 0s • green 0s • offset 0s';
    return;
  }
  const it = items[Math.max(0,Math.min(currentIdx,items.length-1))];
  const {state, remaining, phase} = compute(nowMs, it);

  nameEl.textContent = it.name + (it.lat?` • ${it.lat.toFixed(5)},${it.lng?.toFixed(5)||''}`:'');
  stateEl.textContent = state;
  stateEl.className = 'stateBadge ' + (state==='GREEN'?'stateGREEN':'stateRED');
  timerEl.textContent = fmtClock(remaining);
  timerEl.classList.toggle('blink', Math.floor(remaining)<=5);
  subEl.textContent = `cycle ${it.cycle_sec}s • green ${it.green_sec}s • offset ${it.offset_sec}s • phase ${Math.floor(phase)}s`;
}

// 타이머: 200ms 간격으로 부드러운 카운트다운
setInterval(()=>render(), 200);

// UI binds
document.getElementById('addBtn').onclick = () =>{
  const obj = {
    name: document.getElementById('name').value.trim()||'이름없음',
    cycle_sec: +document.getElementById('cycle').value,
    green_sec: +document.getElementById('green').value,
    offset_sec: +document.getElementById('offset').value||0,
    reference_epoch: document.getElementById('epoch').value.trim(),
    lat: parseFloat(document.getElementById('lat').value)||null,
    lng: parseFloat(document.getElementById('lng').value)||null,
  };
  addItem(obj);
};

document.getElementById('demoBtn').onclick = () => {
  // 샘플: 신사역 푸른저축은행 — 입력칸 채우고, 바로 리스트에 추가까지
  const sample = {
    name: '신사역 푸른저축은행',
    cycle_sec: 190,
    green_sec: 55,
    offset_sec: 0,
    // ↓ 현장 UTC로 바꿔도 OK. 일단 테스트용으로 유지
    reference_epoch: '2025-09-06T11:50:50Z',
    lat: null,
    lng: null,
  };
  // 입력칸에도 보이기
  document.getElementById('name').value = sample.name;
  document.getElementById('cycle').value = sample.cycle_sec;
  document.getElementById('green').value = sample.green_sec;
  document.getElementById('offset').value = sample.offset_sec;
  document.getElementById('epoch').value = sample.reference_epoch;
  // 리스트에 즉시 추가
  addItem(sample);
  // 라이브 패널 맨 위 항목으로 고정
  currentIdx = items.length - 1;
  render();
  alert('샘플이 추가됐어요. 라이브 패널에서 바로 확인해보세요!');
};

document.getElementById('exportBtn').onclick = () =>{
  const blob = new Blob([JSON.stringify(items, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'intersections.json';
  a.click(); URL.revokeObjectURL(a.href);
};

document.getElementById('clearBtn').onclick = () =>{
  if(confirm('모든 항목을 삭제할까요?')){ items=[]; save(); render(); }
};

document.getElementById('geoBtn').onclick = () =>{
  if(!navigator.geolocation){ alert('Geolocation 미지원'); return; }
  navigator.geolocation.getCurrentPosition(pos=>{
    const {latitude, longitude} = pos.coords;
    // 간단 최근접 찾기
    let bestIdx = -1, bestDist = Infinity;
    items.forEach((it, i)=>{
      if(!(it.lat&&it.lng)) return;
      const d = haversine(latitude, longitude, it.lat, it.lng);
      if(d < bestDist){ bestDist = d; bestIdx = i; }
    });
    if(bestIdx<0){ alert('좌표가 입력된 항목이 없습니다.'); return; }
    // 라이브 패널 대상 고정
    currentIdx = bestIdx; render();
    alert(`가까운 항목: ${items[bestIdx].name} (약 ${bestDist.toFixed(0)}m)`);
  }, err=> alert('위치 오류: '+err.message), {enableHighAccuracy:false, timeout:8000});
};

function haversine(lat1, lon1, lat2, lon2){
  const R=6371000; const toRad=x=>x*Math.PI/180;
  const dphi=toRad(lat2-lat1), dl=toRad(lon2-lon1);
  const p1=toRad(lat1), p2=toRad(lat2);
  const a=Math.sin(dphi/2)**2 + Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

load(); render();
</script>
</body>
</html>

